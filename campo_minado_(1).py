# -*- coding: utf-8 -*-
"""Campo_minado (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h7d2LV_VZCCyfMbxxk3ouqRuvrrPk1Bh

## Usando matriz para definir tamanho do tabuleiro
"""

class Matrix:
  VAZIO = 0

  def __init__(self, altura, largura): # Define dados iniciais da classe
    self.altura = altura
    self.largura = largura
    self.grid = self.criar_grid()


  def criar_grid(self): # Monta o grid/tabuleiro do jogo
    linha_vazia = [Matrix.VAZIO for i in range(self.largura)] # Setando a largura
    grid = [linha_vazia.copy() for i in range(self.altura)] # Copiando a linha 

    return grid

  def pegar_elemento(self, pos_i, pos_j):
    return self.grid[pos_i][pos_j]

  def definir_elemento(self, pos_i, pos_j, elemento):
    self.grid[pos_i][pos_j] = elemento

"""## Classe que define regras do jogo"""

import random

class CampoMinado:
  RATE = 0.16
  MINE = -1
  VAZIO= 0

  GAMING    = 1
  GAME_WIN  = 2
  GAME_OVER = 3

  def __init__(self):
    self.largura = 6 # Largura do tabuleiro
    self.altura = 6 # Altura do tabuleiro
    self.qtd_minas = int((self.largura * self.altura) * CampoMinado.RATE) # Fra√ß√£o que representa as bombas
    self.posicao_minas = self.gerador_minas()
    self.qtd_quadrados_livres = (self.largura * self.altura) - self.qtd_minas # Fra√ß√£o que representa campos vazios

    self.grid = Matrix(self.altura, self.largura) # Montando grid
    self.grid = self.colocar_minas(self.grid) # Colocando as bombas
    self.grid = self.contar_minas_em_volta(self.grid) # Calculando bombas nos campos vizinhos

    # preview control
    self.estado_grid = Matrix(self.altura, self.largura) # Salvando estado do grid

  def atualizar_campos_livres(self): # Reduzindo as casas vazias (muda com o decorrer do jogo)
    self.qtd_quadrados_livres -= 1

  def colocar_minas(self, grid): # Coloca as minas nas posi√ß√µes setadas em posicao_minas
    for (i, j) in self.posicao_minas:
      grid.definir_elemento(i, j, CampoMinado.MINE)

    return grid

  def gerador_minas(self): # Seleciona aleatoriamente quais campos ter√£o uma bomba
    posicao_minas = set()

    while len(posicao_minas) != self.qtd_minas:
      i = random.randint(0, self.altura - 1)
      j = random.randint(0, self.largura - 1)

      posicao_minas.add((i,j))

    return posicao_minas

  def posicao_valida(self, linha, coluna): # Verifica se a posi√ß√£o escolhida pelo jogador √© v√°lida
    if linha < 0 or linha >= self.altura:
      return False
    if coluna < 0 or coluna >= self.largura:
      return False
    
    return True

  def checar_mina(self, grid, linha, coluna): # Verifica se tem uma bomba na posi√ß√£o escolhida
    if not self.posicao_valida(linha, coluna): # Se a posi√ß√£o n√£o √© v√°lida
      return False
    if grid.pegar_elemento(linha, coluna) != CampoMinado.MINE: # Se n√£o tem uma bomba na √°rea escolhida
      return False

    return True

  def contar_minas_em_volta(self, grid): # Essa fun√ß√£o verifica em cada lado das casas o n√∫mero de bombas presentes
    # Definindo as casas p√≥ximas
    mov_linha = [0,1, 0,-1, 1,-1, 1,-1]
    mov_coluna = [1,0,-1, 0,-1, 1, 1,-1]

    for linha in range(self.altura):
      for coluna in range(self.largura):
          elemento = grid.pegar_elemento(linha, coluna)

          if elemento == CampoMinado.MINE:
            continue

          for step in range(8):
            i = linha + mov_linha[step]
            j = coluna + mov_coluna[step]

            if self.checar_mina(grid, i, j):
              grid.definir_elemento(linha, coluna, 1 + grid.pegar_elemento(linha, coluna))

    return grid

  def revelar_campos_livres(self, linha, coluna): # Essa fun√ß√£o revela todas as casas que n√£o possuem bombas ao redor por perto
    self.atualizar_campos_livres()
    self.estado_grid.definir_elemento(linha, coluna, 1)

    # Definindo as casas p√≥ximas
    mov_linha = [0,1, 0,-1, 1,-1, 1,-1]
    mov_coluna = [1,0,-1, 0,-1, 1, 1,-1]

    for step in range(8):
      adj_linha = linha + mov_linha[step]
      adj_coluna = coluna + mov_coluna[step]

      if not self.posicao_valida(adj_linha, adj_coluna):
        continue

      elemento_atual = self.grid.pegar_elemento(adj_linha, adj_coluna)

      if elemento_atual != CampoMinado.VAZIO:
        continue
      if self.estado_grid.pegar_elemento(adj_linha, adj_coluna) != Matrix.VAZIO:
        continue

      self.revelar_campos_livres(adj_linha, adj_coluna)


  def validar_coordenadas(self, linha, coluna):
    if linha < 0 or coluna < 0:
      return False
    if linha >= self.altura or coluna >= self.largura:
      return False
    
    return True

  def fazer_movimento(self, linha=-1, coluna=-1):
    if not self.validar_coordenadas(linha, coluna):
      return 

    if self.estado_grid.pegar_elemento(linha, coluna) != Matrix.VAZIO:
      return

    if self.grid.pegar_elemento(linha, coluna) != CampoMinado.VAZIO:
      self.estado_grid.definir_elemento(linha, coluna, 1)
      self.atualizar_campos_livres()
    else:
      self.revelar_campos_livres(linha, coluna)

  def pegar_status(self, linha, coluna): # Fun√ß√£o que determina os estados do game, derrota, vit√≥ria, ou em andamento
    if not self.validar_coordenadas(linha, coluna):
      return CampoMinado.GAMING

    elemento_atual = self.grid.pegar_elemento(linha, coluna)

    if elemento_atual == CampoMinado.MINE:
      return CampoMinado.GAME_OVER

    if self.qtd_quadrados_livres == 0:
      return CampoMinado.GAME_WIN
    return CampoMinado.GAMING

"""## Essas fun√ß√µes s√£o respons√°veis por mostrar as informa√ß√µes na tela"""

import os
import sys
sys.path.append('..')

VAZIO = '‚óª'
MINE  = 'üí£'

YELLOW    = '\033[93m'
GREEN     = '\033[92m'
RED       = '\033[31m'
COLOR_END = '\033[0;0m'

def mostrar_celula(elemento, campo_secreto, mostrar_minas=False):
  if mostrar_minas and campo_secreto == CampoMinado.MINE:
    print(RED + '%4s' %(MINE) + COLOR_END, end='')
  elif elemento != 0:
    print(GREEN + '%4s' %(campo_secreto) + COLOR_END, end='')
  else:
    print(YELLOW + '%4s' %(VAZIO) + COLOR_END, end='')

def mostrar_tabuleiro(game, status):
  os.system('cls')

  print('%23s' %'CAMPO MINADO')
  print('%29s\n' %('QUANTIDADE DE MINAS: %d' %(game.qtd_minas)))

  grid = game.grid
  estado_grid = game.estado_grid

  # Posicionando horizontalmente
  for coluna in range(grid.largura):
    if coluna == 0:
      print("%8d" %(coluna), end='')
    elif coluna != grid.largura - 1:
      print("%4d" %(coluna), end='')
    else:
      print("%4d" %(coluna))

  for linha in range(grid.altura):
    # Posicionando verticalmente
    print('%4d' %(linha), end='')

    for coluna in range(grid.largura):
      elemento = estado_grid.pegar_elemento(linha, coluna)
      campo_secreto = grid.pegar_elemento(linha, coluna)

      if status == CampoMinado.GAME_OVER or status == CampoMinado.GAME_WIN:
        mostrar_celula(elemento, campo_secreto, True)
      else:
        mostrar_celula(elemento, campo_secreto, False)

    print()

def pegar_coordenadas():

  try:
    coordenadas = [int(i) for i in input('\n       Digite as coordenadas - Ex.: 2 3: ').split()]
  except:
    return [-1, -1]

  return coordenadas if (len(coordenadas) == 2) else [-1, -1]

def mostrar_msg_fim(msg):
  print('\n\n%23s\n' %(msg))
  input('Aperte qualquer tecla para continuar...')

def menu_selecao():
  os.system('clear')

  print('''
CAMPO MINADO - PYTHON
  
1 - JOGAR
2 - SAIR
  ''')

  op = input('\nSelecione uma op√ß√£o: ')
  return op

"""## Esse loop executar√° o jogo at√© que o jogador seleciona a op√ß√£o SAIR0"""

while True:
  op = menu_selecao()

  if op == '1':
    game = CampoMinado()
    # Posi√ß√£o inv√°lida
    linha, coluna = -1, -1
    status = CampoMinado.GAMING

    while status == CampoMinado.GAMING:
      game.fazer_movimento(linha, coluna)
      status = game.pegar_status(linha, coluna)
      mostrar_tabuleiro(game, status)

      if status == CampoMinado.GAME_OVER:
        mostrar_msg_fim('VOC√ä PERDEU!')
      elif status == CampoMinado.GAME_WIN:
        mostrar_msg_fim('VOC√ä VENCEU!!!')
      else:
        linha, coluna = pegar_coordenadas()

  elif op == '2': # sair
    break